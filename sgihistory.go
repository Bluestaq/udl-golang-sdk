// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

package unifieddatalibrary

import (
	"context"
	"net/http"
	"net/url"
	"time"

	"github.com/stainless-sdks/unifieddatalibrary-go/internal/apijson"
	"github.com/stainless-sdks/unifieddatalibrary-go/internal/apiquery"
	"github.com/stainless-sdks/unifieddatalibrary-go/internal/requestconfig"
	"github.com/stainless-sdks/unifieddatalibrary-go/option"
	"github.com/stainless-sdks/unifieddatalibrary-go/packages/pagination"
	"github.com/stainless-sdks/unifieddatalibrary-go/packages/param"
	"github.com/stainless-sdks/unifieddatalibrary-go/packages/resp"
)

// SgiHistoryService contains methods and other services that help with interacting
// with the unifieddatalibrary API.
//
// Note, unlike clients, this service does not read variables from the environment
// automatically. You should not instantiate this service directly, and instead use
// the [NewSgiHistoryService] method instead.
type SgiHistoryService struct {
	Options []option.RequestOption
}

// NewSgiHistoryService generates a new service that applies the given options to
// each request. These options are applied after the parent client's options (if
// there is one), and before any request-specific options.
func NewSgiHistoryService(opts ...option.RequestOption) (r SgiHistoryService) {
	r = SgiHistoryService{}
	r.Options = opts
	return
}

// Service operation to dynamically query historical data by a variety of query
// parameters not specified in this API documentation. See the queryhelp operation
// (/udl/&lt;datatype&gt;/queryhelp) for more details on valid/required query
// parameter information.
func (r *SgiHistoryService) List(ctx context.Context, query SgiHistoryListParams, opts ...option.RequestOption) (res *pagination.OffsetPage[SgiHistoryListResponse], err error) {
	var raw *http.Response
	opts = append(r.Options[:], opts...)
	opts = append([]option.RequestOption{option.WithResponseInto(&raw)}, opts...)
	path := "udl/sgi/history"
	cfg, err := requestconfig.NewRequestConfig(ctx, http.MethodGet, path, query, &res, opts...)
	if err != nil {
		return nil, err
	}
	err = cfg.Execute()
	if err != nil {
		return nil, err
	}
	res.SetPageConfig(cfg, raw)
	return res, nil
}

// Service operation to dynamically query historical data by a variety of query
// parameters not specified in this API documentation. See the queryhelp operation
// (/udl/&lt;datatype&gt;/queryhelp) for more details on valid/required query
// parameter information.
func (r *SgiHistoryService) ListAutoPaging(ctx context.Context, query SgiHistoryListParams, opts ...option.RequestOption) *pagination.OffsetPageAutoPager[SgiHistoryListResponse] {
	return pagination.NewOffsetPageAutoPager(r.List(ctx, query, opts...))
}

// Service operation to dynamically query historical data by a variety of query
// parameters not specified in this API documentation, then write that data to the
// Secure Content Store. See the queryhelp operation
// (/udl/&lt;datatype&gt;/queryhelp) for more details on valid/required query
// parameter information.
func (r *SgiHistoryService) Aodr(ctx context.Context, query SgiHistoryAodrParams, opts ...option.RequestOption) (err error) {
	opts = append(r.Options[:], opts...)
	opts = append([]option.RequestOption{option.WithHeader("Accept", "")}, opts...)
	path := "udl/sgi/history/aodr"
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodGet, path, query, nil, opts...)
	return
}

// Service operation to return the count of records satisfying the specified query
// parameters. This operation is useful to determine how many records pass a
// particular query criteria without retrieving large amounts of data. See the
// queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on
// valid/required query parameter information.
func (r *SgiHistoryService) Count(ctx context.Context, query SgiHistoryCountParams, opts ...option.RequestOption) (res *string, err error) {
	opts = append(r.Options[:], opts...)
	opts = append([]option.RequestOption{option.WithHeader("Accept", "text/plain")}, opts...)
	path := "udl/sgi/history/count"
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodGet, path, query, &res, opts...)
	return
}

// Model representation of space weather/solar, geomagnetic, and radiation belt
// indices.
type SgiHistoryListResponse struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format.
	ClassificationMarking string `json:"classificationMarking,required"`
	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data
	// may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects,
	// events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world
	// datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and
	// requirements, and for validating technical, functional, and performance
	// characteristics.
	//
	// Any of "REAL", "TEST", "SIMULATED", "EXERCISE".
	DataMode SgiHistoryListResponseDataMode `json:"dataMode,required"`
	// ISO8601 UTC Time the data was received and processed from the source. Typically
	// a source provides data for a date window with each transmission including past,
	// present, and future predicted values.
	EffectiveDate time.Time `json:"effectiveDate,required" format:"date-time"`
	// ISO8601 UTC Time of the index value. This could be a past, current, or future
	// predicted value. Note: sgiDate defines the start time of the time window for
	// this data record.
	SgiDate time.Time `json:"sgiDate,required" format:"date-time"`
	// Source of the data.
	Source string `json:"source,required"`
	// Unique identifier of the record, auto-generated by the system.
	ID string `json:"id"`
	// Signal analyzer's input attenuation level, in decibels. Attenuation is a setting
	// on the hardware that measures the power of a signal.
	AnalyzerAttenuation float64 `json:"analyzerAttenuation"`
	// Ap is the planetary geomagnetic 2 nT index (00-21 UT) for the timespan specified
	// in apDuration. If apDuration is null, a 3 hour duration should be assumed.
	Ap float64 `json:"ap"`
	// The time, in hours, for which the Ap index value is valid. If null, a span of 3
	// hours is assumed.
	ApDuration int64 `json:"apDuration"`
	// Array containing the degree of the temperature coefficients. The coeffDegree and
	// coeffOrder arrays must be the same length.
	CoeffDegree []int64 `json:"coeffDegree"`
	// Array containing the order of the temperature coefficients. The coeffDegree and
	// coeffOrder arrays must be the same length.
	CoeffOrder []int64 `json:"coeffOrder"`
	// Time the row was created in the database, auto-populated by the system.
	CreatedAt time.Time `json:"createdAt" format:"date-time"`
	// Application user who created the row in the database, auto-populated by the
	// system.
	CreatedBy string `json:"createdBy"`
	// Array containing the cosine spherical-harmonic coefficients for Exospheric
	// temperature (DTC) difference. Each array element corresponds to the positional
	// index of the coeffDegree and coeffOrder arrays.
	Ctce []float64 `json:"ctce"`
	// Array containing the cosine spherical-harmonic coefficients for Inflection
	// temperature (DTX) difference. Each array element corresponds to the positional
	// index of the coeffDegree and coeffOrder arrays.
	Ctci []float64 `json:"ctci"`
	// Disturbance Storm Time geomagnetic index in nT.
	Dst float64 `json:"dst"`
	// delta exospheric temperature correction in units of K.
	Dtc float64 `json:"dtc"`
	// Extreme Ultraviolet (EUV) proxy, E10.7, in x10-22 Watts per meter squared per
	// Hertz, is the integrated solar EUV energy flux at the top of atmosphere and
	// normalized to solar flux units.
	E10 float64 `json:"e10"`
	// E54 (E10-Bar), in x10-22 Watts per meter squared per Hertz, uses the past
	// 54-days E10 values to determine the E10 average.
	E54 float64 `json:"e54"`
	// Daily solar 10.7 cm radio flux in x10-22 Watts per meter squared per Hertz.
	F10 float64 `json:"f10"`
	// Daily F10.7 index - high range, in x10-22 Watts per meter squared per Hertz.
	// This field usually applies to forecast values, based on the consensus of the
	// Solar Cycle 24 Prediction Panel.
	F10High float64 `json:"f10High"`
	// Daily F10.7 index - low range, in x10-22 Watts per meter squared per Hertz. This
	// field usually applies to forecast values, based on the consensus of the Solar
	// Cycle 24 Prediction Panel.
	F10Low float64 `json:"f10Low"`
	// 54 day solar 10.7 cm radio flux in x10-22 Watts per meter squared per Hertz.
	F54 float64 `json:"f54"`
	// 81 day solar 10.7 cm radio flux in x10-22 Watts per meter squared per Hertz.
	F81 float64 `json:"f81"`
	// Array of individual power spectral density (PSD) frequencies of the signal, in
	// megahertz. This array should correspond with the same-sized array of powers.
	Frequencies []float64 `json:"frequencies"`
	// The maximum measured gamma deflection during the kpDuration timespan. If
	// kpDuration is null, a 3 hour duration should be assumed.
	Gamma int64 `json:"gamma"`
	// Unique identifier of the reporting sensor.
	IDSensor string `json:"idSensor"`
	// The maximum measured K-Index at the associated station during the kpDuration
	// timespan. The K-Index is a unitless measure (0 - 9) of the deviation in the
	// Earth's magnetic field from normal at the station geographic location, with 0
	// indicating the absence of geomagnetic disturbance, and 9 indicating the most
	// significant disturbance. If kpDuration is null, a 3 hour duration should be
	// assumed.
	KIndex int64 `json:"kIndex"`
	// The Planetary K-index (Kp) over the kpDuration timespan. The Kp-Index is the
	// average K-Index for the entire Earth, utilizing a unitless scale (0-9, in
	// incremenets of 1/3), with 0 indicating the absence of geomagnetic disturbance,
	// and 9 indicating the most significant disturbance. If kpDuration is null, a 3
	// hour duration should be assumed.
	Kp float64 `json:"kp"`
	// The time, in hours, over which the K, Kp, and/or gamma index values are
	// measured. If null, a span of 3 hours is assumed.
	KpDuration int64 `json:"kpDuration"`
	// Daily M10.7 index for 100-110 km heating of O2 by solar photosphere. 160 nm SRC
	// emissions in x10-22 Watts per meter squared per Hertz.
	M10 float64 `json:"m10"`
	// 54 day M10.7 index for 100-110 km heating of O2 by solar photosphere. 160 nm SRC
	// emissions in x10-22 Watts per meter squared per Hertz.
	M54 float64 `json:"m54"`
	// The transmitted DCA mode of the record (1-3).
	Mode int64 `json:"mode"`
	// The normalization factor that has already been applied to the index value prior
	// to record ingest. Typically used to normalize the index value to a particular
	// interval. Units of the normalization factor may vary depending on the provider
	// of this data (REACH, POES, CEASE3, etc.).
	NormFactor float64 `json:"normFactor"`
	// Observed baseline values of the frequencies specified in the frequencies field,
	// in solar flux units. The baseline values will be used to help detect abnormal
	// readings from the sun that might indicate a flare or other solar activity.
	ObservedBaseline []int64 `json:"observedBaseline"`
	// Originating system or organization which produced the data, if different from
	// the source. The origin may be different than the source if the source was a
	// mediating system which forwarded the data on behalf of the origin system. If
	// null, the source may be assumed to be the origin.
	Origin string `json:"origin"`
	// The originating source network on which this record was created, auto-populated
	// by the system.
	OrigNetwork string `json:"origNetwork"`
	// Optional identifier provided by the reporting source to indicate the sensor
	// identifier which produced this data. This may be an internal identifier and not
	// necessarily a valid sensor ID.
	OrigSensorID string `json:"origSensorId"`
	// Array of individual power spectral density (PSD) powers of the signal, in watts.
	// This array should correspond with the same-sized array of frequencies.
	Powers []float64 `json:"powers"`
	// The precedence of data in this record (O = Immediate, P = Priority, R = Routine,
	// Y = Emergency, Z = Flash).
	//
	// Any of "O", "P", "R", "Y", "Z".
	Precedence SgiHistoryListResponsePrecedence `json:"precedence"`
	// Optional URI location in the document repository of the raw file parsed by the
	// system to produce this record. To download the raw file, prepend
	// https://udl-hostname/scs/download?id= to this value.
	RawFileUri string `json:"rawFileURI"`
	// The timespan over which the associated radiation belt index is factored. If
	// rbDuration is null, a 24 hour duration should be assumed. Note: rbDuration
	// defines the length of the time window for this data record. The time window
	// start time is defined by sgiDate, and the time window end time is defined by
	// sgiDate plus rbDuration.
	RbDuration int64 `json:"rbDuration"`
	// The value of the radiation belt index. This is the ratio of current intensity of
	// a radiation belt to long-term average value. It's long-term average should be
	// close to 1. Depending on the type of belt sensor, this ratio may measure Flux
	// (number of particles / (cm^2 sec energy solid-angle)), dose rate (rad per
	// second), or relative counts of particles per time (counts per second). The index
	// value may also be normalized, the normalization value typically represents an
	// average of the sensor measurements taken within a region over a given time
	// interval. See the normFactor field for the specific normalization factor, if
	// provided.
	RbIndex float64 `json:"rbIndex"`
	// Region code for the associated radiation belt index. This is the code associated
	// with the corresponding radiation belt location. See the provider card for
	// reference to specific region code definitions.
	RbRegionCode int64 `json:"rbRegionCode"`
	// Daily S10.7 index for >200 km heating of O by solar chromosphere. 28.4-30.4 nm
	// emissions in x10-22 Watts per meter squared per Hertz.
	S10 float64 `json:"s10"`
	// 54 day S10.7 index for >200 km heating of O by solar chromosphere. 28.4-30.4 nm
	// emissions in x10-22 Watts per meter squared per Hertz.
	S54 float64 `json:"s54"`
	// State indicating Issued (I), Nowcast (N), or Predicted (P) values for this
	// record.
	//
	// Any of "I", "N", "P".
	State SgiHistoryListResponseState `json:"state"`
	// The name/location of the station that collected the geomagnetic data for this
	// record.
	StationName string `json:"stationName"`
	// Array containing the sine spherical-harmonic coefficients for Exospheric
	// temperature (DTC) difference. Each array element corresponds to the positional
	// index of the coeffDegree and coeffOrder arrays.
	Stce []float64 `json:"stce"`
	// Array containing the sine spherical harmonic coefficients for Inflection
	// temperature (DTX) difference. Each array element corresponds to the positional
	// index of the coeffDegree and coeffOrder arrays.
	Stci []float64 `json:"stci"`
	// Daily sunspot number.
	SunspotNum float64 `json:"sunspotNum"`
	// Daily sunspot number - high range. This field usually applies to forecast
	// values, based on the consensus of the Solar Cycle 24 Prediction Panel.
	SunspotNumHigh float64 `json:"sunspotNumHigh"`
	// Daily sunspot number - low range. This field usually applies to forecast values,
	// based on the consensus of the Solar Cycle 24 Prediction Panel.
	SunspotNumLow float64 `json:"sunspotNumLow"`
	// Optional array of provider/source specific tags for this data, where each
	// element is no longer than 32 characters, used for implementing data owner
	// conditional access controls to restrict access to the data. Should be left null
	// by data providers unless conditional access controls are coordinated with the
	// UDL team.
	Tags []string `json:"tags"`
	// Optional identifier to track a commercial or marketplace transaction executed to
	// produce this data.
	TransactionID string `json:"transactionId"`
	// The type of data contained in this record (e.g. HASDM, JBH09, K-Index, PSD-dB,
	// RBI, RFI-SFU, etc).
	Type string `json:"type"`
	// Time the row was last updated in the database, auto-populated by the system.
	UpdatedAt time.Time `json:"updatedAt" format:"date-time"`
	// Application user who updated the row in the database, auto-populated by the
	// system.
	UpdatedBy string `json:"updatedBy"`
	// Daily Y10.7 index for 85-90 km heating of N2, O2, H2O, NO by solar coronal.
	// 0.1-0.8 nm and Lya 121 nm emissions in x10-22 Watts per meter squared per Hertz.
	Y10 float64 `json:"y10"`
	// 54 day Y10.7 index for 85-90 km heating of N2, O2, H2O, NO by solar coronal.
	// 0.1-0.8 nm and Lya 121 nm emissions in x10-22 Watts per meter squared per Hertz.
	Y54 float64 `json:"y54"`
	// Metadata for the response, check the presence of optional fields with the
	// [resp.Field.IsPresent] method.
	JSON struct {
		ClassificationMarking resp.Field
		DataMode              resp.Field
		EffectiveDate         resp.Field
		SgiDate               resp.Field
		Source                resp.Field
		ID                    resp.Field
		AnalyzerAttenuation   resp.Field
		Ap                    resp.Field
		ApDuration            resp.Field
		CoeffDegree           resp.Field
		CoeffOrder            resp.Field
		CreatedAt             resp.Field
		CreatedBy             resp.Field
		Ctce                  resp.Field
		Ctci                  resp.Field
		Dst                   resp.Field
		Dtc                   resp.Field
		E10                   resp.Field
		E54                   resp.Field
		F10                   resp.Field
		F10High               resp.Field
		F10Low                resp.Field
		F54                   resp.Field
		F81                   resp.Field
		Frequencies           resp.Field
		Gamma                 resp.Field
		IDSensor              resp.Field
		KIndex                resp.Field
		Kp                    resp.Field
		KpDuration            resp.Field
		M10                   resp.Field
		M54                   resp.Field
		Mode                  resp.Field
		NormFactor            resp.Field
		ObservedBaseline      resp.Field
		Origin                resp.Field
		OrigNetwork           resp.Field
		OrigSensorID          resp.Field
		Powers                resp.Field
		Precedence            resp.Field
		RawFileUri            resp.Field
		RbDuration            resp.Field
		RbIndex               resp.Field
		RbRegionCode          resp.Field
		S10                   resp.Field
		S54                   resp.Field
		State                 resp.Field
		StationName           resp.Field
		Stce                  resp.Field
		Stci                  resp.Field
		SunspotNum            resp.Field
		SunspotNumHigh        resp.Field
		SunspotNumLow         resp.Field
		Tags                  resp.Field
		TransactionID         resp.Field
		Type                  resp.Field
		UpdatedAt             resp.Field
		UpdatedBy             resp.Field
		Y10                   resp.Field
		Y54                   resp.Field
		ExtraFields           map[string]resp.Field
		raw                   string
	} `json:"-"`
}

// Returns the unmodified JSON received from the API
func (r SgiHistoryListResponse) RawJSON() string { return r.JSON.raw }
func (r *SgiHistoryListResponse) UnmarshalJSON(data []byte) error {
	return apijson.UnmarshalRoot(data, r)
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data
// may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects,
// events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world
// datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and
// requirements, and for validating technical, functional, and performance
// characteristics.
type SgiHistoryListResponseDataMode string

const (
	SgiHistoryListResponseDataModeReal      SgiHistoryListResponseDataMode = "REAL"
	SgiHistoryListResponseDataModeTest      SgiHistoryListResponseDataMode = "TEST"
	SgiHistoryListResponseDataModeSimulated SgiHistoryListResponseDataMode = "SIMULATED"
	SgiHistoryListResponseDataModeExercise  SgiHistoryListResponseDataMode = "EXERCISE"
)

// The precedence of data in this record (O = Immediate, P = Priority, R = Routine,
// Y = Emergency, Z = Flash).
type SgiHistoryListResponsePrecedence string

const (
	SgiHistoryListResponsePrecedenceO SgiHistoryListResponsePrecedence = "O"
	SgiHistoryListResponsePrecedenceP SgiHistoryListResponsePrecedence = "P"
	SgiHistoryListResponsePrecedenceR SgiHistoryListResponsePrecedence = "R"
	SgiHistoryListResponsePrecedenceY SgiHistoryListResponsePrecedence = "Y"
	SgiHistoryListResponsePrecedenceZ SgiHistoryListResponsePrecedence = "Z"
)

// State indicating Issued (I), Nowcast (N), or Predicted (P) values for this
// record.
type SgiHistoryListResponseState string

const (
	SgiHistoryListResponseStateI SgiHistoryListResponseState = "I"
	SgiHistoryListResponseStateN SgiHistoryListResponseState = "N"
	SgiHistoryListResponseStateP SgiHistoryListResponseState = "P"
)

type SgiHistoryListParams struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the
	// queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid
	// query fields that can be selected.
	Columns param.Opt[string] `query:"columns,omitzero" json:"-"`
	// (One or more of fields 'effectiveDate, sgiDate' are required.) ISO8601 UTC Time
	// the data was received and processed from the source. Typically a source provides
	// solar data for a date window with each transmission including past, present, and
	// future predicted values. (YYYY-MM-DDTHH:MM:SS.sssZ)
	EffectiveDate param.Opt[time.Time] `query:"effectiveDate,omitzero" format:"date-time" json:"-"`
	FirstResult   param.Opt[int64]     `query:"firstResult,omitzero" json:"-"`
	MaxResults    param.Opt[int64]     `query:"maxResults,omitzero" json:"-"`
	// (One or more of fields 'effectiveDate, sgiDate' are required.) ISO8601 UTC Time
	// of the index value. This could be a past, current, or future predicted value.
	// Note: sgiDate defines the start time of the time window for this data record.
	// (YYYY-MM-DDTHH:MM:SS.sssZ)
	SgiDate param.Opt[time.Time] `query:"sgiDate,omitzero" format:"date-time" json:"-"`
	paramObj
}

// IsPresent returns true if the field's value is not omitted and not the JSON
// "null". To check if this field is omitted, use [param.IsOmitted].
func (f SgiHistoryListParams) IsPresent() bool { return !param.IsOmitted(f) && !f.IsNull() }

// URLQuery serializes [SgiHistoryListParams]'s query parameters as `url.Values`.
func (r SgiHistoryListParams) URLQuery() (v url.Values, err error) {
	return apiquery.MarshalWithSettings(r, apiquery.QuerySettings{
		ArrayFormat:  apiquery.ArrayQueryFormatComma,
		NestedFormat: apiquery.NestedQueryFormatBrackets,
	})
}

type SgiHistoryAodrParams struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the
	// queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid
	// query fields that can be selected.
	Columns param.Opt[string] `query:"columns,omitzero" json:"-"`
	// (One or more of fields 'effectiveDate, sgiDate' are required.) ISO8601 UTC Time
	// the data was received and processed from the source. Typically a source provides
	// solar data for a date window with each transmission including past, present, and
	// future predicted values. (YYYY-MM-DDTHH:MM:SS.sssZ)
	EffectiveDate param.Opt[time.Time] `query:"effectiveDate,omitzero" format:"date-time" json:"-"`
	FirstResult   param.Opt[int64]     `query:"firstResult,omitzero" json:"-"`
	MaxResults    param.Opt[int64]     `query:"maxResults,omitzero" json:"-"`
	// optional, notification method for the created file link. When omitted, EMAIL is
	// assumed. Current valid values are: EMAIL, SMS.
	Notification param.Opt[string] `query:"notification,omitzero" json:"-"`
	// optional, field delimiter when the created file is not JSON. Must be a single
	// character chosen from this set: (',', ';', ':', '|'). When omitted, "," is used.
	// It is strongly encouraged that your field delimiter be a character unlikely to
	// occur within the data.
	OutputDelimiter param.Opt[string] `query:"outputDelimiter,omitzero" json:"-"`
	// optional, output format for the file. When omitted, JSON is assumed. Current
	// valid values are: JSON and CSV.
	OutputFormat param.Opt[string] `query:"outputFormat,omitzero" json:"-"`
	// (One or more of fields 'effectiveDate, sgiDate' are required.) ISO8601 UTC Time
	// of the index value. This could be a past, current, or future predicted value.
	// Note: sgiDate defines the start time of the time window for this data record.
	// (YYYY-MM-DDTHH:MM:SS.sssZ)
	SgiDate param.Opt[time.Time] `query:"sgiDate,omitzero" format:"date-time" json:"-"`
	paramObj
}

// IsPresent returns true if the field's value is not omitted and not the JSON
// "null". To check if this field is omitted, use [param.IsOmitted].
func (f SgiHistoryAodrParams) IsPresent() bool { return !param.IsOmitted(f) && !f.IsNull() }

// URLQuery serializes [SgiHistoryAodrParams]'s query parameters as `url.Values`.
func (r SgiHistoryAodrParams) URLQuery() (v url.Values, err error) {
	return apiquery.MarshalWithSettings(r, apiquery.QuerySettings{
		ArrayFormat:  apiquery.ArrayQueryFormatComma,
		NestedFormat: apiquery.NestedQueryFormatBrackets,
	})
}

type SgiHistoryCountParams struct {
	// (One or more of fields 'effectiveDate, sgiDate' are required.) ISO8601 UTC Time
	// the data was received and processed from the source. Typically a source provides
	// solar data for a date window with each transmission including past, present, and
	// future predicted values. (YYYY-MM-DDTHH:MM:SS.sssZ)
	EffectiveDate param.Opt[time.Time] `query:"effectiveDate,omitzero" format:"date-time" json:"-"`
	FirstResult   param.Opt[int64]     `query:"firstResult,omitzero" json:"-"`
	MaxResults    param.Opt[int64]     `query:"maxResults,omitzero" json:"-"`
	// (One or more of fields 'effectiveDate, sgiDate' are required.) ISO8601 UTC Time
	// of the index value. This could be a past, current, or future predicted value.
	// Note: sgiDate defines the start time of the time window for this data record.
	// (YYYY-MM-DDTHH:MM:SS.sssZ)
	SgiDate param.Opt[time.Time] `query:"sgiDate,omitzero" format:"date-time" json:"-"`
	paramObj
}

// IsPresent returns true if the field's value is not omitted and not the JSON
// "null". To check if this field is omitted, use [param.IsOmitted].
func (f SgiHistoryCountParams) IsPresent() bool { return !param.IsOmitted(f) && !f.IsNull() }

// URLQuery serializes [SgiHistoryCountParams]'s query parameters as `url.Values`.
func (r SgiHistoryCountParams) URLQuery() (v url.Values, err error) {
	return apiquery.MarshalWithSettings(r, apiquery.QuerySettings{
		ArrayFormat:  apiquery.ArrayQueryFormatComma,
		NestedFormat: apiquery.NestedQueryFormatBrackets,
	})
}
